
## 一 2019年10月06日 CPU 性能篇

### 1 遇到性能瓶颈的排查思路

```pwd
有监控的情况下，首先去看看监控大盘，看看有没有异常报警，如果初期还没有监控的情况我会按照下面步骤去看看系统层面有没有异常
1、我首先会去看看系统的平均负载，使用top或者htop命令查看,平均负载体现的是系统的一个整体情况，他应该是cpu、内存、磁盘性能的一个综合，一般是平均负载的值大于机器cpu的核数，这时候说明机器资源已经紧张了
2、平均负载高了以后，接下来就要看看具体是什么资源导致，我首先会在top中看cpu每个核的使用情况，如果占比很高，那瓶颈应该是cpu,接下来就要看看是什么进程导致的
3、如果cpu没有问题，那接下来我会去看内存，首先是用free去查看内存的是用情况，但不直接看他剩余了多少，还要结合看看cache和buffer，然后再看看具体是什么进程占用了过高的内存，我也是是用top去排序
4、内存没有问题的话就要去看磁盘了，磁盘我用iostat去查看，我遇到的磁盘问题比较少
5、还有就是带宽问题，一般会用iftop去查看流量情况，看看流量是否超过的机器给定的带宽
6、涉及到具体应用的话，就要根据具体应用的设定参数来查看，比如连接数是否查过设定值等
7、如果系统层各个指标查下来都没有发现异常，那么就要考虑外部系统了，比如数据库、缓存、存储等
8、书籍 Linux性能之巅

```

### 2 平均负载

```pwd
一、什么是平均负载
正确定义：单位时间内，系统中处于可运行状态和不可中断状态的平均进程数。
错误定义：单位时间内的cpu使用率。
可运行状态的进程：正在使用cpu或者正在等待cpu的进程，即ps aux命令下STAT处于R状态的进程
不可中断状态的进程：处于内核态关键流程中的进程，且不可被打断，如等待硬件设备IO响应，ps命令D状态的进程
理想状态：每个cpu上都有一个活跃进程，即平均负载数等于cpu数
过载经验值：平均负载高于cpu数量70%的时候 例如cpu 2 负载为3.4那么要关系系统性能了
二、相关命令
cpu核数: lscpu、 grep 'model name' /proc/cpuinfo | wc -l
显示平均负载：uptime、top，显示的顺序是最近1分钟、5分钟、15分钟，从此可以看出平均负载的趋势
watch -d uptime: -d会高亮显示变化的区域
strees: 压测命令，--cpu cpu压测选项，-i io压测选项，-c 进程数压测选项，--timeout 执行时间
mpstat: 多核cpu性能分析工具，-P ALL监视所有cpu
pidstat: 进程性能分析工具，-u 显示cpu利用率

三、平均负载与cpu使用率的区别
CPU使用率：单位时间内cpu繁忙情况的统计
情况1：CPU密集型进程，CPU使用率和平均负载基本一致
情况2：IO密集型进程，平均负载升高，CPU使用率不一定升高
情况3：大量等待CPU的进程调度，平均负载升高，CPU使用率也升高

四、平均负载过高时，如何调优
工具：stress、sysstat，yum即可安装
1. CPU密集型进程case：
mpstat -P ALL 5: -P ALL表示监控所有CPU，5表示每5秒刷新一次数据，观察是否有某个cpu的%usr会很高，但iowait应很低
pidstat -u 5 1：每5秒输出一组数据，观察哪个进程%cpu很高，但是%wait很低，极有可能就是这个进程导致cpu飚高
2. IO密集型进程case：
mpstat -P ALL 5: 观察是否有某个cpu的%iowait很高，同时%usr也较高
pidstat -u 5 1：观察哪个进程%wait较高，同时%CPU也较高
iotop iostat
3. 大量进程case：
pidstat -u 5 1：观察那些%wait较高的进程是否有很多
4 htop 看负载 cpu密集型的应用，它的负载颜色是绿色偏高，iowait的操作，它的负载颜色是红色偏高等等 atop 
5 top和ps或者lsof来分析
五 相关笔记
http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html
http://note.youdao.com/noteshare?id=7f3c0445f1828c8cd2094de4b59a331b
iostat
https://www.cnblogs.com/ftl1012/p/iostat.html
https://www.jellythink.com/archives/438
https://www.zybuluo.com/Gugoole/note/1354842
```
### 3 上下文切换

```pwd
* 上下文切换是什么？
上下文切换是对任务当前运行状态的暂存和恢复
* CPU为什么要进行上下文切换？
当多个进程竞争CPU的时候，CPU为了保证每个进程能公平被调度运行，采取了处理任务时间分片的机制，轮流处理多个进程，由于CPU处理速度非常快，在人类的感官上认为是并行处理，实际是"伪"并行，同一时间只有一个任务在运行处理。
* 上下文切换主要消耗什么资源，为什么说上下文切换次数过多不可取？
根据 Tsuna 的测试报告，每次上下文切换都需要几十纳秒到到微秒的CPU时间，这些时间对CPU来说，就好比人类对1分钟或10分钟的感觉概念。在分秒必争的计算机处理环境下，浪费太多时间在切换上，只能会降低真正处理任务的时间，表象上导致延时、排队、卡顿现象发生。
* 上下文切换的过程
(1)记录当前任务的上下文(即寄存器和计算器等所有的状态)；(2)找到新任务的上下文并加载； (3)切换到新任务的程序计算器位置，恢复其任务。  
* 上下文切换分几种？
进程上下文切换、线程上下文切换、中断上下文切换
* 什么情况下会触发上下文切换？
系统调用、进程状态转换(运行、就绪、阻塞)、时间片耗尽、系统资源不足、sleep、优先级调度、硬件中断等
* 线程上下文切换和进程上下文切换的最大区别？
线程是调度的基本单位，进程是资源拥有的基本单位，同属一个进程的线程，发生上下文切换，只切换线程的私有数据，共享数据不变，因此速度非常快。进程间的上下文切换是从用户态到内核态的切换,性能消耗比较大
* 中断上下文切换，如何理解？
为了快速响应硬件的事件(如USB接入)，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而打断其它进程执行时，需要进行上下文切换。中断事件过多，会无谓的消耗CPU资源，导致进程处理时间延长。
* 有哪些减少上下文切换的技术用例？
数据库连接池（复用连接）、合理设置应用的最大进程，线程数、直接内存访问DMA、零拷贝技术

```

### 4 上下文切换排查

```pwd
过多上下文切换会缩短进程运行时间
vmstat 1 1：分析内存使用情况、cpu上下文切换和中断的次数。cs每秒上下文切换的次数，in每秒中断的次数，r运行或等待cpu的进程数，b中断睡眠状态的进程数。
pidstat -w 5：查看每个进程详细情况。cswch（每秒自愿）上下文切换次数，如系统资源不足导致，nvcswch每秒非自愿上下文切换次数，如cpu时间片用完或高优先级线程
案例分析：
sysbench：多线程的基准测试工具，模拟context switch
终端1：sysbench --threads=10 --max-time=300 threads run
终端2：vmstat 1：sys列占用84%说明主要被内核占用，ur占用16%；r就绪队列8；in中断处理1w，cs切换139w==>等待进程过多，频繁上下文切换，内核cpu占用率升高
终端3：pidstat -w -u 1：sysbench的cpu占用100%（-wt发现子线程切换过多），其他进程导致上下文切换 pidstat -wt 1
watch -d cat /proc/interupts ：查看另一个指标中断次数，在/proc/interupts中读取，发现重调度中断res变化速度最快
总结：cswch过多说明资源IO问题，nvcswch过多说明调度争抢cpu过多，中断次数变多说明cpu被中断程序调用

```


### 5 cpu 分析

```pwd
用户空间节拍率( USER_HZ)是一个固定设置
[root@dbayang ~]# grep 'CONFIG_HZ=' /boot/config-$(uname -r)
CONFIG_HZ=1000

1. CPU使用率怎么计算的？
    前面讲过CPU使用率是单位时间内CPU使用情况的统计，如果我们只关注系统的CPU和任务统计信息，可以通过／proc/stat来统计，但是反应的是开机时间以来平均CPU使用率，没有意义
 CPU使用率常见的重要指标有：         
user（us）
用户态CPU的时间，注意不包括nice时间
nice（ni）
低优先级用户态CPU时间
system（sys）
内核态CPU时间
idle（id）
空闲时间，不包括等待I/O的时间（iowait）
iowait（wa）
等待I/O的CPU时间
irq（hi）
硬中断的CPU时间
softirq（si）
处理软中断的CPU时间
CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比
CPU使用率 = 1 - （空闲时间）／ （总CPU时间）
但是实时CPU使用率都是通过以下公式计算的：
CPU使用率高 = 1 - 【空闲时间(new）- 空闲时间（old）】／【总CPU时间（new）- 总CPU时间（old）】
2. 如何查看CPU使用率
   top 显示了系统总体的 CPU 和内存使用情况，以及各个进程的资源使用情况
   Ps 则只显示了每个进程的资源使用情况
   mpstat -P ALL 

3. CPU使用率过高怎么办？
     方法一：Perf top，它能够实时显示占用 CPU 时钟最多的函数或者指令，因此可以查找热点函数
     方法二：perf record 和 perf report。可用于离线分析
4 工具查看
1： 对于pidstat,vmstat,top无法定位到问题的时候。
2： 可以选择perf record -g 记录。perf record -ag -- sleep 2
3： 用perf report查看是否可以定位到问题。
4： 用pstree | grep [xx],这样定位到具体的调用方法里。
5： 用grep [xx] -r [项目文件],找到具体代码位置。
6： 查找源码，定位到具体位置，修改。
https://github.com/brendangregg/perf-tools
```
### 6 top 命宁 参数

```pwd

R:运行 Running或Runnable的缩写 表示进程在CPU的就绪队列中，正在运行或正在等待运行
I:空闲 Idle的缩写，用在不可中断睡眠的内核线程上。空闲线程不会导致平均负载升高，D状态的会导致平均负载升高
D:不可中断睡眠 Disk Sleep的缩写 表示进程正在跟硬件交互，并且交互过程中不允许被其他进程或中断打断
S:可中断睡眠 Interruptible Sleep的缩写 表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入R状态
Z:僵尸 Zombie缩写 进程已经结束，但父进程还没有回收它的资源（如进程的描述符、PID等）
T:暂停 Stopped或Traced的缩写，表示进程处于暂停或者跟踪状态


1、进程的多种状态，D (Disk Sleep) 状态的进程，会导致平均负载升高
2、僵尸进程：
（1）父子进程的运行是异步的过程，父进程需要知道子进程是何时关闭的
（2）子进程需要父进程来收尸，但父进程没有安装SIGCHLD信号处理函数调用wait或waitpid（）等待子进程结束，或是子进程执行太快，父进程还没来得及处理子进程状态
（3）父进程退出后，init进程会自动接手子进程，进行清理
（4）僵尸进程已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集
（5）大量的僵尸进程会用尽 PID 进程号，导致新进程不能创建
3、会话和进程组
4、实操
（1）查看了僵尸进程 查看僵尸进程的命令 ps -e -o stat,ppid,pid,cmd | egrep '^[Zz]' 或 ps -ef | grep "defunct"，停止父进程后，僵尸进程会被回收

```
### 7 出现大量僵尸进程

```pwd

现象：
①iowait太高，导致平均负载升高，并且达到了系统CPU的个数
②僵尸进程不断增多
分析过程：
1.先分析iowait升高的原因
一般iowait升高，可能的原因是i/o问题
①用dstat 命令同时查看cpu和i/o对比情况（如 dstat 1 10 间隔1秒输出10组数据），通过结果可以发现iowait升高时，磁盘读请求（read）升高
所以推断iowait升高是磁盘读导致
②定位磁盘读的进程，使用top命令查看处于不可中断状态（D）的进程PID
③查看对应进程的磁盘读写情况，使用pidstat命令，加上-d参数，可以看到i/o使用情况（如 pidstat -d -p <pid> 1 3）,发现处于不可中断状态的进程都没有进行磁盘读写
④继续使用pidstat命令，但是去掉进程号，查看所有进程的i/o情况（pidstat -d 1 20），可以定位到进行磁盘读写的进程。我们知道进程访问磁盘，需要使用系统调用，
下面的重点就是找到该进程的系统调用
⑤使用strace查看进程的系统调用 strace -p <pid>
发现报了 strace:attach :ptrace(PTRACE_SIZE，6028)：Operation not peritted,说没有权限，我是使用的root权限，所以这个时候就要查看进程的状态是否正常
⑥ps aux | grep <pid> 发现进程处于Z状态，已经变成了僵尸进程，所以不能进行系统调用分析了
⑦既然top和pidstat都不能找出问题，使用基于事件记录的动态追踪工具

这里看top 就可以看到了 s  栏出现很多z 状态的进程 task 里 z 数目很多 其实先 top  看进程 然后 pidstat -d 查看进程使用资源使用情况
然后 找到 读写很大的进程 strace 跟踪 或者 ps aux | grep pid 查看进程状态 如果是z 那么要找到父进程 pstree - pid
```

### 8 系统软中断排查思路

```pwd
什么是软中断?
 硬中断是硬件产生的,比如键盘、鼠标的输入，硬盘的写入读取、网卡有数据了；软中断是软件产生的，比如程序内的定时器、[文中提到的RCU锁]。
 网卡的处理实际是有硬中断和软中断的。
问题:有没有碰到过因为软中断出现的性能问题?
通过vmstat 检测到系统的软中断每秒有100W+次.
分析
1.检测是哪个线程占用了cpu: top -H -p XX 1 / pidstat -wut -p XX 1
2.在进程中打印各线程号. 找到是哪个线程.[ 此过程也可以省略 但可以快速定位线程]
3.第一步应该可以判断出来中断数过高. 再使用 cat /proc/softirqs 查看是哪种类型的中断数过高.  cat /proc/interrupts 硬中断
NET_RX 表示网络接收中断，而 NET_TX 表示网络发送中断。

```
### 9 系统的软中断CPU使用率升高

```pwd
步骤
top 看到 负载和cpu 都不高  但是主要的cpu 都在 si(软中断上) 性能慢
watch -d cat /proc/softirqs 查看是哪种类型的中断数过高 TIMER（定时中断）、NET_RX（网络接收）、SCHED（内核调度）、RCU（RCU 锁）
看到 NET_RX 发生变化 就用 sar 工具 网络报告
# -n DEV 表示显示网络收发的报告，间隔 1 秒输出一组数据
$ sar -n DEV 1
15:03:46        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
15:03:47         eth0  12607.00   6304.00    664.86    358.11      0.00      0.00      0.00      0.01
15:03:47      docker0   6302.00  12604.00    270.79    664.66      0.00      0.00      0.00      0.00
15:03:47           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
15:03:47    veth9f6bbcd   6302.00  12604.00    356.95    664.66      0.00      0.00      0.00      0.05
第二列：IFACE 表示网卡。第三、四列：rxpck/s 和 txpck/s 分别表示每秒接收、发送的网络帧数，也就是  PPS。第五、六列：rxkB/s 和 txkB/s 分别表示每秒接收、发送的千字节数，也就是  BPS。

从中看到 eth0 接收数据比较大 但是发送比较少 说明接收中断了
然后 抓包 tcpdump
# -i eth0 只抓取 eth0 网卡，-n 不解析协议名和主机名
# tcp port 80 表示只抓取 tcp 协议并且端口号为 80 的网络帧
$ tcpdump -i eth0 -n tcp port 80
15:11:32.678966 IP 192.168.0.2.18238 > 192.168.0.30.80: Flags [S], seq 458303614, win 512, length 0
看到是 Flags [S] 就证明是SYN 包 接收中断了

其他
找网络相关的错误，可以有几种方式。
1. 找系统类的错误， dmesg | tail
2. 直接的网络错误 sar -n ETCP 1 或者 sar -n EDEV 1
3.查看网络状态， netstat -s 或者 watch -d netstat -s
4.网络状态的统计 ss -ant | awk '{++s[$1]} END {for(k in s) print k,s[k]}'
```
### 10 分析流程和命令
```pwd
pidstat 中， %wait 表示进程等待 CPU 的时间百分比。此时进程是运行状态。
top 中 ，iowait% 则表示等待 I/O 的 CPU 时间百分比。此时进程处于不可中断睡眠态。
等待 CPU 的进程已经在 CPU 的就绪队列中，处于运行状态；而等待 I/O 的进程则处于不可中断状态。

```
![ cpu](https://static001.geekbang.org/resource/image/7a/17/7a445960a4bc0a58a02e1bc75648aa17.png?w=1034&h=198&f=png&s=47686)
![ cpu](https://static001.geekbang.org/resource/image/b0/ca/b0c67a7196f5ca4cc58f14f959a364ca.png?w=1034&h=198&f=png&s=47686)



